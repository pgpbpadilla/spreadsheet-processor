package org.pgpb.spreadsheet;

import com.google.common.collect.ImmutableList;
import org.pgpb.evaluation.ValueError;
import org.slf4j.LoggerFactory;

import java.util.Arrays;
import java.util.List;

/*
 * This Java source file was generated by the Gradle 'init' task.
 */
public class Spreadsheet {
    private String[][] cells;

    public Spreadsheet(int rows, int columns) {
        if (rows < 1 || columns < 1) {
            cells = new String[0][0];
        } else {
            cells = new String[rows][];
            for (int r = 0; r < rows; r++) {
                cells[r] = new String[columns];
            }
        }
    }

    private static Dimensions parseHeader(String[] header) {
        int rowCount = Integer.parseInt(header[0]);
        int columnCount = Integer.parseInt(header[1]);

        if (rowCount < 0 || columnCount < 0) {
            throw new RuntimeException("Invalid headers");
        }

        return new Dimensions(rowCount, columnCount);
    }

    public static Spreadsheet fromTsvLines(List<String> lines) {
        String[] header = lines.get(0).split("\\t");
        Dimensions dimensions = parseHeader(header);

        String [][] cells = lines.stream()
            .skip(1)
            .map(l -> l.split("\\t"))
            .map(Arrays::asList)
            .map(entries -> entries.toArray(new String[0]))
            .toArray(String[][]::new);

        Spreadsheet spreadsheet = new Spreadsheet(dimensions.rows, dimensions.columns);
        spreadsheet.setCells(cells);
        return spreadsheet;
    }

    public int getRowCount() {
        return cells.length;
    }

    public int getColumnCount() {
        if (hasRows() && hasColumns()) {
            return cells[0].length;
        }
        return 0;
    }

    private boolean hasColumns() {
        return null != cells[0];
    }

    private boolean hasRows() {
        return cells.length > 0;
    }

    public String getContent(String address) {
        Coordinate coordinate;
        try {
            coordinate = Coordinate.fromAddress(address);
        } catch (RuntimeException e) {
            return ValueError.INVALID_ADDRESS_FORMAT.toString();
        }
        if (!cellExists(coordinate)) {
            return ValueError.CELL_NOT_FOUND.toString();
        }
        return cells[coordinate.row][coordinate.column];
    }

    private boolean cellExists(Coordinate c) {
        if (!hasRows()) {
            return false;
        }
        if (!hasColumns()) {
            return false;
        }
        if (c.row > getRowCount()) {
            return false;
        }
        return c.column <= getColumnCount();
    }

    public void setCells(String[][] cells) {
        this.cells = cells;
    }

    public ImmutableList<String> toTSVLines() {
        return Arrays.stream(cells)
            .map(Arrays::asList)
            .map(cellRow -> String.join("\t", cellRow)
            ).collect(ImmutableList.toImmutableList());
    }

    public ImmutableList<String[]> getRows() {
        return ImmutableList.copyOf(Arrays.asList(cells));
    }

    public static class Dimensions {
        public final int rows;
        public final int columns;

        public Dimensions(int rowCount, int columnCount) {
            rows = rowCount;
            columns = columnCount;
        }
    }
}
